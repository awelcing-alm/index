// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// ========= CORE TENANCY =========

model Account {
  id               String           @id @default(uuid()) @db.Uuid
  zephr_account_id String           @unique @db.VarChar(255) // natural key from Zephr
  name             String           @db.VarChar(255)
  email_address    String?          @db.VarChar(255)
  number_of_seats  Int?
  tenant_id        String?          @db.VarChar(255)

  // relations
  users            UserAccount[]    // M2M via pivot
  groups           Group[]
  grants           AccountGrant[]

  // timestamps
  created_at       DateTime         @default(now()) @db.Timestamptz(6)
  updated_at       DateTime         @default(now()) @db.Timestamptz(6)

  @@index([zephr_account_id], map: "acct_by_zephr")
}

model User {
  id              String          @id @default(uuid()) @db.Uuid
  zephr_user_id   String          @unique @db.VarChar(255) // natural key from Zephr
  email           String          @db.VarChar(320)
  // Zephr attributes (demographics etc). Export reads from here.
  attributes      Json?           @default("{}")
  email_verified  Boolean?        @default(false)

  // optional profile-ish fields (mostly for convenience in UI)
  firstname       String?         @db.VarChar(255)
  lastname        String?         @db.VarChar(255)
  role            String?         @db.VarChar(50)         // "owner" | "admin" | "user"
  status          String?         @db.VarChar(50)         // "active" | "inactive" etc
  last_login      DateTime?       @db.Timestamptz(6)

  // relations
  accounts        UserAccount[]   // M2M via pivot
  memberships     GroupMembership[]
  newsletterSubs  UserNewsletter[]

  created_at      DateTime        @default(now()) @db.Timestamptz(6)
  updated_at      DateTime        @default(now()) @db.Timestamptz(6)

  @@index([email], map: "user_by_email")
  @@index([zephr_user_id], map: "user_by_zephr")
}

model UserAccount {
  // M2M (User â†” Account), holds per-tenant role/status if you want
  user_id    String  @db.Uuid
  account_id String  @db.Uuid
  role       String? @db.VarChar(50)
  status     String? @db.VarChar(50)

  user       User    @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  account    Account @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([user_id, account_id])
  @@index([account_id, user_id], map: "ua_by_account_user")
}

/// ========= GROUPS & MEMBERSHIPS =========

model Group {
  id                String             @id @default(uuid()) @db.Uuid
  account_id        String             @db.Uuid
  slug              String
  name              String
  icon              String?            @db.VarChar(32)
  color             String?            @db.VarChar(7) // e.g. #RRGGBB
  demographics      Json               @default("{}")
  default_template_id String?          @db.Uuid

  account           Account            @relation(fields: [account_id], references: [id], onDelete: Cascade)
  default_template  Template?          @relation(fields: [default_template_id], references: [id], onDelete: SetNull)
  memberships       GroupMembership[]

  created_at        DateTime           @default(now()) @db.Timestamptz(6)
  updated_at        DateTime           @default(now()) @db.Timestamptz(6)

  @@unique([account_id, slug], map: "group_slug_per_account")
  @@index([account_id], map: "group_by_account")
}

model GroupMembership {
  group_id String @db.Uuid
  user_id  String @db.Uuid

  group    Group  @relation(fields: [group_id], references: [id], onDelete: Cascade)
  user     User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  assigned_by String?   // optionally store who assigned
  assigned_at DateTime  @default(now()) @db.Timestamptz(6)

  @@id([group_id, user_id])
  @@index([user_id], map: "gm_by_user")
  @@index([group_id], map: "gm_by_group")
}

/// ========= NEWSLETTERS =========

model Newsletter {
  id          String            @id @default(uuid()) @db.Uuid
  name        String            @unique @db.VarChar(255)
  description String?
  created_at  DateTime?         @default(now()) @db.Timestamptz(6)

  subscribers UserNewsletter[]
}

model UserNewsletter {
  user_id       String      @db.Uuid
  newsletter_id String      @db.Uuid
  subscribed    Boolean     @default(true)
  open_rate     Decimal?    @default(0) @db.Decimal(5, 2)
  click_rate    Decimal?    @default(0) @db.Decimal(5, 2)
  created_at    DateTime?   @default(now()) @db.Timestamptz(6)
  updated_at    DateTime?   @default(now()) @db.Timestamptz(6)

  user         User         @relation(fields: [user_id], references: [id], onDelete: Cascade)
  newsletter   Newsletter   @relation(fields: [newsletter_id], references: [id], onDelete: Cascade)

  @@id([user_id, newsletter_id])
  @@index([newsletter_id], map: "un_by_newsletter")
}

/// ========= PRODUCTS / ENTITLEMENTS / GRANTS =========

model Product {
  id               String         @id @default(uuid()) @db.Uuid
  zephr_product_id String         @unique @db.VarChar(255)
  label            String         @db.VarChar(255)
  description      String?

  grants           AccountGrant[]

  created_at       DateTime?      @default(now()) @db.Timestamptz(6)
}

model Entitlement {
  id                    String         @id @default(uuid()) @db.Uuid
  zephr_entitlement_id  String         @unique @db.VarChar(255)
  label                 String?
  description           String?
  type                  String?        @db.VarChar(50)

  grants                AccountGrant[]

  created_at            DateTime?      @default(now()) @db.Timestamptz(6)
}

/// One row per Zephr grant. It can reference either a product OR an entitlement.
model AccountGrant {
  id            String     @id @default(uuid()) @db.Uuid
  account_id    String     @db.Uuid
  product_id    String?    @db.Uuid
  entitlement_id String?   @db.Uuid

  // Zephr metadata
  zephr_grant_id String    @unique @db.VarChar(255)
  expiry_state   String?   @db.VarChar(50)
  start_time     DateTime? @db.Timestamptz(6)
  end_time       DateTime? @db.Timestamptz(6)

  account       Account     @relation(fields: [account_id], references: [id], onDelete: Cascade)
  product       Product?    @relation(fields: [product_id], references: [id], onDelete: SetNull)
  entitlement   Entitlement?@relation(fields: [entitlement_id], references: [id], onDelete: SetNull)

  @@index([account_id], map: "grant_by_account")
  @@index([product_id], map: "grant_by_product")
  @@index([entitlement_id], map: "grant_by_entitlement")
}

/// ========= ATTRIBUTE DEFINITIONS (for demographics UI) =========

model AttributeDefinition {
  slug           String  @id
  label          String?
  input_type     String?    // text | select | multiselect | date, etc.
  required       Boolean?   @default(false)
  select_options Json?      // array of options for select-like inputs
}

/// ========= TEMPLATES (optional: export + bulk ops) =========

model Template {
  id          String   @id @default(uuid()) @db.Uuid
  account_id  String   @db.Uuid
  name        String
  description String?
  attributes  Json     @default("{}") // the attribute payload you apply to users

  account     Account  @relation(fields: [account_id], references: [id], onDelete: Cascade)

  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @db.Timestamptz(6)

  @@unique([account_id, name], map: "template_name_per_account")
  @@index([account_id], map: "template_by_account")
}
